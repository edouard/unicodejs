#!/usr/bin/env python

"""Generates unicodejs.*(properties|categories).js from Unicode data"""

import re, urllib2, os

def extractProperties( url, jsname, full, propPatterns, excludeSurrogates=False ):
	# a list of property name strings like "Extend", "Format" etc
	properties = []

	# range[property] -> character range list e.g. [0x0040, [0x0060-0x0070], 0x00A3, ...]
	ranges = {}
	for line in urllib2.urlopen( url ):
		line = line.strip()
		# Ignore comment or blank lines
		if re.search( r"^\s*(#|$)", line ): continue
		# Find things like one of the following:
		#   XXXX       ; propertyname
		#   XXXX..YYYY ; propertyname
		m = re.search( r"^([0-9A-F]{4,6})(?:\.\.([0-9A-F]{4,6}))?\s*;\s*(\w+)\s*#", line )
		if not m:
			raise ValueError( "Bad line: %r" % line )
		start = int( m.group( 1 ), 16 )
		end = int( m.group( 2 ) or m.group( 1 ), 16 )
		propText = m.group( 3 )
		if jsname == 'graphemebreakproperties' and start == 'D800' and end == 'DFFF':
			continue # raw surrogates are not treated

		for propPattern in propPatterns:
			m = re.search( propPattern, propText )
			if m:
				propName = m.group( 1 )
				if not ranges.has_key( propName ):
					properties.append( propName )
					ranges[ propName ] = []
				ranges[ propName ].append( ( start, end ) )

	# Translate ranges into js fragments
	fragments = []
	for prop in properties:
		rangeStrings = []
		propRanges = ranges[ prop ]

		# Merge consecutive ranges
		propRanges.sort()
		i = 1
		while i < len( propRanges ):
			if propRanges[ i - 1 ][ 1 ] + 1 == propRanges[ i ][ 0 ]:
				propRanges[ i - 1 ] = (
					propRanges[ i - 1 ][ 0 ],
					propRanges[ i ][ 1 ],
				)
				del propRanges[ i ]
			else:
				i += 1

		for start, end in propRanges:
			if excludeSurrogates and start == 0xD800 and end == 0xDFFF:
				continue
			elif end == start:
				rangeStrings.append( "0x%04X" % start )
			elif end == start + 1:
				rangeStrings.append( "0x%04X" % start )
				rangeStrings.append( "0x%04X" % end )
			else:
				rangeStrings.append( "[0x%04X, 0x%04X]" % ( start, end ) )
		fragments.append( prop.replace( "_", "" ) + ": [" + ", ".join( rangeStrings ) + "]" )

	# Write js file
	js  = "// This file is GENERATED by tools/unicodejs-properties.py\n"
	js += "// DO NOT EDIT\n"
	js += "unicodeJS." + jsname + " = {\n\t"
	if not full:
		js += "// partial extraction only\n\t"
	js += ",\n\t".join( fragments )
	js += "\n};\n"
	jsFilename = os.path.dirname( os.path.realpath( __file__ ) ) + "/../src/unicodejs." + jsname + ".js"
	open( jsFilename, "w" ).write( js )
	print "wrote " + jsFilename

extractions = [
	{
		"url": "http://unicode.org/Public/UNIDATA/DerivedCoreProperties.txt",
		"jsname": "derivedcoreproperties",
		"full": False,
		"propPatterns": ( "^(Alphabetic)$", ),
	},
	{
		"url": "http://www.unicode.org/Public/UNIDATA/extracted/DerivedGeneralCategory.txt",
		"jsname": "derivedgeneralcategories",
		"full": False,
		"propPatterns": ( "^(Pc)$", "^(M).*$" ),
	},
	{
		"url": "http://www.unicode.org/Public/UNIDATA/auxiliary/GraphemeBreakProperty.txt",
		"jsname": "graphemebreakproperties",
		"full": True,
		"propPatterns": ( "^(.*)$", ),
		"excludeSurrogates": True,
	},
	{
		"url": "http://www.unicode.org/Public/UNIDATA/auxiliary/WordBreakProperty.txt",
		"jsname": "wordbreakproperties",
		"full": True,
		"propPatterns": ( "^(.*)$", ),
	},
	{
		"url": "http://www.unicode.org/Public/UCD/latest/ucd/extracted/DerivedBidiClass.txt",
		"jsname": "derivedbidiclasses",
		"full": False,
		"propPatterns": ( "^(L|R|AL)$", ),
	}
]

for extraction in extractions:
	extractProperties(**extraction)
